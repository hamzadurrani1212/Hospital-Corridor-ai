# app/services/alerts_store.py
"""
In-memory alert storage with persistence capabilities.
Stores alerts generated by the processing pipeline.
"""

import time
from typing import List, Dict, Optional
from collections import defaultdict
from datetime import datetime, timedelta
import threading


class AlertStore:
    def __init__(self):
        self._alerts: List[Dict] = []
        self._lock = threading.Lock()
        self._people_detections: Dict[str, int] = defaultdict(int)  # date -> count
    
    def add_alert(self, alert_data: Dict) -> Dict:
        """Add a new alert to the store."""
        with self._lock:
            # Ensure alert has required fields
            alert = {
                "id": alert_data.get("id", str(int(time.time() * 1000))),
                "type": alert_data.get("type", "UNKNOWN"),
                "severity": alert_data.get("severity", "warning"),
                "title": alert_data.get("title", "Alert"),
                "description": alert_data.get("description", ""),
                "location": alert_data.get("location", "Unknown"),
                "snapshot": alert_data.get("snapshot"),
                "timestamp": alert_data.get("timestamp", time.time()),
                "acknowledged": False,
                "confidence": alert_data.get("confidence"),
                "person_info": alert_data.get("person_info"),
                "behavior": alert_data.get("behavior"),
            }
            
            self._alerts.insert(0, alert)  # Most recent first
            
            # Track person detection for today
            today = datetime.now().strftime("%Y-%m-%d")
            self._people_detections[today] += 1
            
            # Keep only last 1000 alerts in memory
            if len(self._alerts) > 1000:
                self._alerts = self._alerts[:1000]
            
            return alert
    
    def get_all(self, limit: int = 100) -> List[Dict]:
        """Get all alerts, most recent first."""
        with self._lock:
            return self._alerts[:limit]
    
    def get_recent(self, limit: int = 10) -> List[Dict]:
        """Get most recent alerts."""
        with self._lock:
            return self._alerts[:limit]
    
    def get_active_count(self) -> int:
        """Get count of unacknowledged alerts."""
        with self._lock:
            return sum(1 for a in self._alerts if not a.get("acknowledged", False))
    
    def acknowledge(self, alert_id: str) -> bool:
        """Mark an alert as acknowledged."""
        with self._lock:
            for alert in self._alerts:
                if str(alert.get("id")) == str(alert_id):
                    alert["acknowledged"] = True
                    return True
            return False
    
    def get_by_id(self, alert_id: str) -> Optional[Dict]:
        """Get a specific alert by ID."""
        with self._lock:
            for alert in self._alerts:
                if str(alert.get("id")) == str(alert_id):
                    return alert
            return None
    
    def get_people_detected_today(self) -> int:
        """Get count of people detected today."""
        with self._lock:
            today = datetime.now().strftime("%Y-%m-%d")
            return self._people_detections.get(today, 0)
    
    def get_by_type(self, alert_type: str, limit: int = 50) -> List[Dict]:
        """Get alerts filtered by type."""
        with self._lock:
            filtered = [a for a in self._alerts if a.get("type") == alert_type]
            return filtered[:limit]
    
    def get_by_severity(self, severity: str, limit: int = 50) -> List[Dict]:
        """Get alerts filtered by severity."""
        with self._lock:
            filtered = [a for a in self._alerts if a.get("severity") == severity]
            return filtered[:limit]
    
    def clear_old_alerts(self, days: int = 7):
        """Remove alerts older than specified days."""
        with self._lock:
            cutoff = time.time() - (days * 24 * 60 * 60)
            self._alerts = [a for a in self._alerts if a.get("timestamp", 0) > cutoff]


# Global singleton instance
alert_store = AlertStore()
